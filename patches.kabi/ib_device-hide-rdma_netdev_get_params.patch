From: Thomas Bogendoerfer <tbogendoerfer@suse.de>
Subject: kabi, protect struct ib_device
Patch-mainline: never, kabi
References: bsc#1168503

To fix bsc#1168503 is necessary to backport commit
f6a8a19bb11b46d60250ddc4e3e1ba6aa166f488 which introduced the new
field rdma_netdev_get_params into struct ib_device. Since struct
ib_device is a sub struct of the hardware device structs appending
it to the end doesn't work. Since rdma_netdev_get_params is a
replacement API to alloc_rdma_netdev we could put both methods
into a union and add a bitfield to select, which one the hardware
uses.

Signed-off-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>

---
 drivers/infiniband/core/verbs.c           |    4 ++--
 drivers/infiniband/hw/mlx5/main.c         |    4 +++-
 drivers/infiniband/ulp/ipoib/ipoib_main.c |    2 +-
 include/rdma/ib_verbs.h                   |   18 +++++++++++++++++-
 4 files changed, 23 insertions(+), 5 deletions(-)

--- a/drivers/infiniband/core/verbs.c
+++ b/drivers/infiniband/core/verbs.c
@@ -2278,7 +2278,7 @@ struct net_device *rdma_alloc_netdev(str
 	struct net_device *netdev;
 	int rc;
 
-	if (!device->rdma_netdev_get_params)
+	if (!device->has_rdma_netdev_get_params)
 		return ERR_PTR(-EOPNOTSUPP);
 
 	rc = device->rdma_netdev_get_params(device, port_num, type, &params);
@@ -2303,7 +2303,7 @@ int rdma_init_netdev(struct ib_device *d
 	struct rdma_netdev_alloc_params params;
 	int rc;
 
-	if (!device->rdma_netdev_get_params)
+	if (!device->has_rdma_netdev_get_params)
 		return -EOPNOTSUPP;
 
 	rc = device->rdma_netdev_get_params(device, port_num, type, &params);
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@ -4014,8 +4014,10 @@ static void *mlx5_ib_add(struct mlx5_cor
 	dev->ib_dev.get_vector_affinity	= mlx5_ib_get_vector_affinity;
 	if (MLX5_CAP_GEN(mdev, ipoib_enhanced_offloads) &&
 	    ipoib_enhanced &&
-	    IS_ENABLED(CONFIG_MLX5_CORE_IPOIB))
+	    IS_ENABLED(CONFIG_MLX5_CORE_IPOIB)) {
 		dev->ib_dev.rdma_netdev_get_params = mlx5_ib_rn_get_params;
+		dev->ib_dev.has_rdma_netdev_get_params = 1;
+	}
 
 	if (mlx5_core_is_pf(mdev)) {
 		dev->ib_dev.get_vf_config	= mlx5_ib_get_vf_config;
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@ -2415,7 +2415,7 @@ static struct net_device *ipoib_add_port
 		return ERR_PTR(result);
 	}
 
-	if (hca->rdma_netdev_get_params) {
+	if (hca->has_rdma_netdev_get_params) {
 		int rc = hca->rdma_netdev_get_params(hca, port,
 						     RDMA_NETDEV_IPOIB,
 						     &params);
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@ -2314,6 +2314,7 @@ struct ib_device {
 	 * Driver implementing alloc_rdma_netdev or rdma_netdev_get_params
 	 * must return -EOPNOTSUPP if it doesn't support the specified type.
 	 */
+#ifdef __GENKSYMS__
 	struct net_device *(*alloc_rdma_netdev)(
 					struct ib_device *device,
 					u8 port_num,
@@ -2321,10 +2322,21 @@ struct ib_device {
 					const char *name,
 					unsigned char name_assign_type,
 					void (*setup)(struct net_device *));
+#else
+	union {
+		struct net_device *(*alloc_rdma_netdev)(
+					struct ib_device *device,
+					u8 port_num,
+					enum rdma_netdev_t type,
+					const char *name,
+					unsigned char name_assign_type,
+					void (*setup)(struct net_device *));
 
-	int (*rdma_netdev_get_params)(struct ib_device *device, u8 port_num,
+		int (*rdma_netdev_get_params)(struct ib_device *device, u8 port_num,
 				      enum rdma_netdev_t type,
 				      struct rdma_netdev_alloc_params *params);
+	};
+#endif
 
 	struct module               *owner;
 	struct device                dev;
@@ -2345,8 +2357,11 @@ struct ib_device {
 	__be64			     node_guid;
 	u32			     local_dma_lkey;
 	u16                          is_switch:1;
+#ifndef __GENKSYMS__
+	u16                          has_rdma_netdev_get_params:1;
+#endif
 	u8                           node_type;
 	u8                           phys_port_cnt;
 	struct ib_device_attr        attrs;
 	struct attribute_group	     *hw_stats_ag;
 	struct rdma_hw_stats         *hw_stats;
